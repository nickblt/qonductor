// This file is @generated by prost-build.
/// Small leaf messages
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueueVersion {
    #[prost(uint64, optional, tag = "1")]
    pub major: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub minor: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Position {
    /// ms epoch
    #[prost(fixed64, optional, tag = "1")]
    pub timestamp: ::core::option::Option<u64>,
    /// ms position
    #[prost(uint32, optional, tag = "2")]
    pub value: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, optional, tag = "1")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateMessage {
    #[prost(string, optional, tag = "1")]
    pub token: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlaybackError {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(int32, optional, tag = "2")]
    pub queue_item_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub error_type: ::core::option::Option<i32>,
}
/// Device / renderer
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceCapabilities {
    #[prost(int32, optional, tag = "1")]
    pub min_audio_quality: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub max_audio_quality: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub volume_remote_control: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub device_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "2")]
    pub friendly_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub brand: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub model: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub serial_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "DeviceType", optional, tag = "6")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "7")]
    pub capabilities: ::core::option::Option<DeviceCapabilities>,
    #[prost(string, optional, tag = "8")]
    pub software_version: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RendererState {
    #[prost(enumeration = "PlayingState", optional, tag = "1")]
    pub playing_state: ::core::option::Option<i32>,
    #[prost(enumeration = "BufferState", optional, tag = "2")]
    pub buffer_state: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub current_position: ::core::option::Option<Position>,
    /// ms
    #[prost(uint32, optional, tag = "4")]
    pub duration: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub current_queue_index: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub next_queue_item_id: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueueRendererState {
    #[prost(enumeration = "PlayingState", optional, tag = "1")]
    pub playing_state: ::core::option::Option<i32>,
    #[prost(enumeration = "BufferState", optional, tag = "2")]
    pub buffer_state: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub current_position: ::core::option::Option<Position>,
    /// ms
    #[prost(uint32, optional, tag = "4")]
    pub duration: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(int32, optional, tag = "6")]
    pub current_queue_item_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub next_queue_item_id: ::core::option::Option<i32>,
}
/// Queue item references
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueueItemRef {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(uint32, optional, tag = "2")]
    pub id: ::core::option::Option<u32>,
}
/// Track with context (snapshots/autoplay)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueTrackRef {
    #[prost(uint64, optional, tag = "1")]
    pub queue_item_id: ::core::option::Option<u64>,
    #[prost(fixed32, optional, tag = "2")]
    pub track_id: ::core::option::Option<u32>,
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "3")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Enums used across messages
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BufferState {
    Unknown = 0,
    Buffering = 1,
    Ok = 2,
    Error = 3,
    Underrun = 4,
}
impl BufferState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "BUFFER_STATE_UNKNOWN",
            Self::Buffering => "BUFFER_STATE_BUFFERING",
            Self::Ok => "BUFFER_STATE_OK",
            Self::Error => "BUFFER_STATE_ERROR",
            Self::Underrun => "BUFFER_STATE_UNDERRUN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUFFER_STATE_UNKNOWN" => Some(Self::Unknown),
            "BUFFER_STATE_BUFFERING" => Some(Self::Buffering),
            "BUFFER_STATE_OK" => Some(Self::Ok),
            "BUFFER_STATE_ERROR" => Some(Self::Error),
            "BUFFER_STATE_UNDERRUN" => Some(Self::Underrun),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayingState {
    Unknown = 0,
    Stopped = 1,
    Playing = 2,
    Paused = 3,
}
impl PlayingState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PLAYING_STATE_UNKNOWN",
            Self::Stopped => "PLAYING_STATE_STOPPED",
            Self::Playing => "PLAYING_STATE_PLAYING",
            Self::Paused => "PLAYING_STATE_PAUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAYING_STATE_UNKNOWN" => Some(Self::Unknown),
            "PLAYING_STATE_STOPPED" => Some(Self::Stopped),
            "PLAYING_STATE_PLAYING" => Some(Self::Playing),
            "PLAYING_STATE_PAUSED" => Some(Self::Paused),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceType {
    Unknown = 0,
    Speaker = 1,
    Speakerbox = 2,
    Tv = 3,
    Speakerbox2 = 4,
    Laptop = 5,
    Phone = 6,
    GoogleCast = 7,
    Headphones = 8,
    Tablet = 9,
}
impl DeviceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "DEVICE_TYPE_UNKNOWN",
            Self::Speaker => "DEVICE_TYPE_SPEAKER",
            Self::Speakerbox => "DEVICE_TYPE_SPEAKERBOX",
            Self::Tv => "DEVICE_TYPE_TV",
            Self::Speakerbox2 => "DEVICE_TYPE_SPEAKERBOX2",
            Self::Laptop => "DEVICE_TYPE_LAPTOP",
            Self::Phone => "DEVICE_TYPE_PHONE",
            Self::GoogleCast => "DEVICE_TYPE_GOOGLE_CAST",
            Self::Headphones => "DEVICE_TYPE_HEADPHONES",
            Self::Tablet => "DEVICE_TYPE_TABLET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEVICE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "DEVICE_TYPE_SPEAKER" => Some(Self::Speaker),
            "DEVICE_TYPE_SPEAKERBOX" => Some(Self::Speakerbox),
            "DEVICE_TYPE_TV" => Some(Self::Tv),
            "DEVICE_TYPE_SPEAKERBOX2" => Some(Self::Speakerbox2),
            "DEVICE_TYPE_LAPTOP" => Some(Self::Laptop),
            "DEVICE_TYPE_PHONE" => Some(Self::Phone),
            "DEVICE_TYPE_GOOGLE_CAST" => Some(Self::GoogleCast),
            "DEVICE_TYPE_HEADPHONES" => Some(Self::Headphones),
            "DEVICE_TYPE_TABLET" => Some(Self::Tablet),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoopMode {
    Unknown = 0,
    Off = 1,
    RepeatOne = 2,
    RepeatAll = 3,
}
impl LoopMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "LOOP_MODE_UNKNOWN",
            Self::Off => "LOOP_MODE_OFF",
            Self::RepeatOne => "LOOP_MODE_REPEAT_ONE",
            Self::RepeatAll => "LOOP_MODE_REPEAT_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOOP_MODE_UNKNOWN" => Some(Self::Unknown),
            "LOOP_MODE_OFF" => Some(Self::Off),
            "LOOP_MODE_REPEAT_ONE" => Some(Self::RepeatOne),
            "LOOP_MODE_REPEAT_ALL" => Some(Self::RepeatAll),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Authenticate {
    #[prost(uint32, optional, tag = "1")]
    pub msg_id: ::core::option::Option<u32>,
    /// ms epoch
    #[prost(uint64, optional, tag = "2")]
    pub msg_date: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub jwt: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscribe {
    #[prost(uint32, optional, tag = "1")]
    pub msg_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub msg_date: ::core::option::Option<u64>,
    /// QCloudProto
    #[prost(uint32, optional, tag = "3")]
    pub proto: ::core::option::Option<u32>,
    /// channel ids
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub channels: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unsubscribe {
    #[prost(uint32, optional, tag = "1")]
    pub msg_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub msg_date: ::core::option::Option<u64>,
    /// QCloudProto
    #[prost(uint32, optional, tag = "3")]
    pub proto: ::core::option::Option<u32>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub channels: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    #[prost(uint32, optional, tag = "1")]
    pub msg_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub msg_date: ::core::option::Option<u64>,
    /// Optional routing
    ///
    /// QCloudProto
    #[prost(uint32, optional, tag = "3")]
    pub proto: ::core::option::Option<u32>,
    /// channel id
    #[prost(bytes = "vec", optional, tag = "4")]
    pub src: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// channel ids
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub dests: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Raw bytes for the selected protocol.
    /// If proto == QP_QCONNECT (1), interpret as QConnectBatch.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Disconnect {
    #[prost(uint32, optional, tag = "1")]
    pub msg_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub msg_date: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "3")]
    pub reconnect: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QCloudMessageType {
    QcloudMessageTypeUnspecified = 0,
    Authenticate = 1,
    Subscribe = 2,
    Unsubscribe = 3,
    Payload = 6,
    Error = 9,
    Disconnect = 10,
}
impl QCloudMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::QcloudMessageTypeUnspecified => "QCLOUD_MESSAGE_TYPE_UNSPECIFIED",
            Self::Authenticate => "AUTHENTICATE",
            Self::Subscribe => "SUBSCRIBE",
            Self::Unsubscribe => "UNSUBSCRIBE",
            Self::Payload => "PAYLOAD",
            Self::Error => "ERROR",
            Self::Disconnect => "DISCONNECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QCLOUD_MESSAGE_TYPE_UNSPECIFIED" => Some(Self::QcloudMessageTypeUnspecified),
            "AUTHENTICATE" => Some(Self::Authenticate),
            "SUBSCRIBE" => Some(Self::Subscribe),
            "UNSUBSCRIBE" => Some(Self::Unsubscribe),
            "PAYLOAD" => Some(Self::Payload),
            "ERROR" => Some(Self::Error),
            "DISCONNECT" => Some(Self::Disconnect),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QCloudProto {
    QpUnknown = 0,
    QpQconnect = 1,
    QpQconnect2 = 2,
    QpQconnect3 = 3,
}
impl QCloudProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::QpUnknown => "QP_UNKNOWN",
            Self::QpQconnect => "QP_QCONNECT",
            Self::QpQconnect2 => "QP_QCONNECT2",
            Self::QpQconnect3 => "QP_QCONNECT3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QP_UNKNOWN" => Some(Self::QpUnknown),
            "QP_QCONNECT" => Some(Self::QpQconnect),
            "QP_QCONNECT2" => Some(Self::QpQconnect2),
            "QP_QCONNECT3" => Some(Self::QpQconnect3),
            _ => None,
        }
    }
}
/// Full snapshot
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueState {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(bool, optional, tag = "4")]
    pub shuffle_mode: ::core::option::Option<bool>,
    #[prost(uint32, repeated, packed = "false", tag = "5")]
    pub shuffled_track_indexes: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_mode: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "8")]
    pub autoplay_tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Insert after a given item
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueTracksInserted {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(int32, optional, tag = "4")]
    pub insert_after: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "5")]
    pub shuffle_seed: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "7")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Add (usually append)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueTracksAdded {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(fixed32, optional, tag = "4")]
    pub shuffle_seed: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Remove by ids
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueTracksRemoved {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, repeated, packed = "false", tag = "3")]
    pub queue_item_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag = "4")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Reorder selected ids after anchor
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueTracksReordered {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, repeated, packed = "false", tag = "3")]
    pub queue_item_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub insert_after: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "5")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Cleared
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueCleared {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrClearQueue {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrQueueLoadTracks {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "3")]
    pub session_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "4")]
    pub queue_position: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "5")]
    pub qobuz_reference_uuid: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub shuffle_pivot_queue_item_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "7")]
    pub shuffle_mode: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "9")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueLoadTracks {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(uint32, optional, tag = "4")]
    pub queue_position: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "5")]
    pub qobuz_reference_uuid: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub shuffle_pivot_queue_item_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "7")]
    pub shuffle_mode: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "9")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrQueueInsertTracks {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(int32, optional, tag = "4")]
    pub insert_after: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "5")]
    pub shuffle_seed: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "7")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrQueueAddTracks {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(fixed32, optional, tag = "4")]
    pub shuffle_seed: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrQueueRemoveTracks {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub queue_item_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, optional, tag = "4")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrQueueReorderTracks {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub queue_item_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4")]
    pub insert_after: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrAutoplayLoadTracks {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(fixed32, repeated, packed = "false", tag = "3")]
    pub track_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "5")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_reset: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "7")]
    pub shuffle_seed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub insert_after: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "9")]
    pub prepend: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub append: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Batch container inside outer WebSocket payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QConnectBatch {
    /// ms epoch
    #[prost(fixed64, optional, tag = "1")]
    pub messages_time: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub messages_id: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub messages: ::prost::alloc::vec::Vec<QConnectMessage>,
}
/// Union message (no oneof to match wire leniency)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QConnectMessage {
    #[prost(int32, optional, tag = "1")]
    pub message_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
    #[prost(message, optional, tag = "3")]
    pub playback_error: ::core::option::Option<PlaybackError>,
    #[prost(message, optional, tag = "4")]
    pub authenticate: ::core::option::Option<AuthenticateMessage>,
    /// Renderer -> Server events
    #[prost(message, optional, tag = "21")]
    pub rndr_srvr_join_session: ::core::option::Option<RndrSrvrJoinSession>,
    #[prost(message, optional, tag = "22")]
    pub rndr_srvr_device_info_updated: ::core::option::Option<RndrSrvrDeviceInfoUpdated>,
    #[prost(message, optional, tag = "23")]
    pub rndr_srvr_state_updated: ::core::option::Option<RndrSrvrStateUpdated>,
    #[prost(message, optional, tag = "30")]
    pub rndr_srvr_renderer_action: ::core::option::Option<RndrSrvrRendererAction>,
    #[prost(message, optional, tag = "25")]
    pub rndr_srvr_volume_changed: ::core::option::Option<RndrSrvrVolumeChanged>,
    #[prost(message, optional, tag = "26")]
    pub rndr_srvr_file_audio_quality_changed: ::core::option::Option<
        RndrSrvrFileAudioQualityChanged,
    >,
    #[prost(message, optional, tag = "27")]
    pub rndr_srvr_device_audio_quality_changed: ::core::option::Option<
        RndrSrvrDeviceAudioQualityChanged,
    >,
    #[prost(message, optional, tag = "28")]
    pub rndr_srvr_max_audio_quality_changed: ::core::option::Option<
        RndrSrvrMaxAudioQualityChanged,
    >,
    #[prost(message, optional, tag = "29")]
    pub rndr_srvr_volume_muted: ::core::option::Option<RndrSrvrVolumeMuted>,
    /// Server -> Renderer commands
    #[prost(message, optional, tag = "41")]
    pub srvr_rndr_set_state: ::core::option::Option<SrvrRndrSetState>,
    #[prost(message, optional, tag = "42")]
    pub srvr_rndr_set_volume: ::core::option::Option<SrvrRndrSetVolume>,
    #[prost(message, optional, tag = "43")]
    pub srvr_rndr_set_active: ::core::option::Option<SrvrRndrSetActive>,
    #[prost(message, optional, tag = "44")]
    pub srvr_rndr_set_max_audio_quality: ::core::option::Option<
        SrvrRndrSetMaxAudioQuality,
    >,
    #[prost(message, optional, tag = "45")]
    pub srvr_rndr_set_loop_mode: ::core::option::Option<SrvrRndrSetLoopMode>,
    #[prost(message, optional, tag = "46")]
    pub srvr_rndr_set_shuffle_mode: ::core::option::Option<SrvrRndrSetShuffleMode>,
    #[prost(message, optional, tag = "47")]
    pub srvr_rndr_set_autoplay_mode: ::core::option::Option<SrvrRndrSetAutoplayMode>,
    /// Controller -> Server
    #[prost(message, optional, tag = "61")]
    pub ctrl_srvr_join_session: ::core::option::Option<CtrlSrvrJoinSession>,
    #[prost(message, optional, tag = "62")]
    pub ctrl_srvr_set_player_state: ::core::option::Option<CtrlSrvrSetPlayerState>,
    #[prost(message, optional, tag = "63")]
    pub ctrl_srvr_set_active_renderer: ::core::option::Option<CtrlSrvrSetActiveRenderer>,
    #[prost(message, optional, tag = "64")]
    pub ctrl_srvr_set_volume: ::core::option::Option<CtrlSrvrSetVolume>,
    #[prost(message, optional, tag = "65")]
    pub ctrl_srvr_clear_queue: ::core::option::Option<CtrlSrvrClearQueue>,
    #[prost(message, optional, tag = "66")]
    pub ctrl_srvr_queue_load_tracks: ::core::option::Option<CtrlSrvrQueueLoadTracks>,
    #[prost(message, optional, tag = "67")]
    pub ctrl_srvr_queue_insert_tracks: ::core::option::Option<CtrlSrvrQueueInsertTracks>,
    #[prost(message, optional, tag = "68")]
    pub ctrl_srvr_queue_add_tracks: ::core::option::Option<CtrlSrvrQueueAddTracks>,
    #[prost(message, optional, tag = "69")]
    pub ctrl_srvr_queue_remove_tracks: ::core::option::Option<CtrlSrvrQueueRemoveTracks>,
    #[prost(message, optional, tag = "70")]
    pub ctrl_srvr_queue_reorder_tracks: ::core::option::Option<
        CtrlSrvrQueueReorderTracks,
    >,
    #[prost(message, optional, tag = "71")]
    pub ctrl_srvr_set_shuffle_mode: ::core::option::Option<CtrlSrvrSetShuffleMode>,
    #[prost(message, optional, tag = "72")]
    pub ctrl_srvr_set_loop_mode: ::core::option::Option<CtrlSrvrSetLoopMode>,
    #[prost(message, optional, tag = "73")]
    pub ctrl_srvr_mute_volume: ::core::option::Option<CtrlSrvrMuteVolume>,
    #[prost(message, optional, tag = "74")]
    pub ctrl_srvr_set_max_audio_quality: ::core::option::Option<
        CtrlSrvrSetMaxAudioQuality,
    >,
    #[prost(message, optional, tag = "75")]
    pub ctrl_srvr_set_queue_state: ::core::option::Option<CtrlSrvrSetQueueState>,
    #[prost(message, optional, tag = "76")]
    pub ctrl_srvr_ask_for_queue_state: ::core::option::Option<CtrlSrvrAskForQueueState>,
    #[prost(message, optional, tag = "77")]
    pub ctrl_srvr_ask_for_renderer_state: ::core::option::Option<
        CtrlSrvrAskForRendererState,
    >,
    #[prost(message, optional, tag = "78")]
    pub ctrl_srvr_set_autoplay_mode: ::core::option::Option<CtrlSrvrSetAutoplayMode>,
    #[prost(message, optional, tag = "79")]
    pub ctrl_srvr_autoplay_load_tracks: ::core::option::Option<
        CtrlSrvrAutoplayLoadTracks,
    >,
    #[prost(message, optional, tag = "80")]
    pub ctrl_srvr_autoplay_remove_tracks: ::core::option::Option<
        CtrlSrvrAutoplayRemoveTracks,
    >,
    /// Server -> Controllers
    #[prost(message, optional, tag = "81")]
    pub srvr_ctrl_session_state: ::core::option::Option<SrvrCtrlSessionState>,
    #[prost(message, optional, tag = "82")]
    pub srvr_ctrl_renderer_state_updated: ::core::option::Option<
        SrvrCtrlRendererStateUpdated,
    >,
    #[prost(message, optional, tag = "83")]
    pub srvr_ctrl_add_renderer: ::core::option::Option<SrvrCtrlAddRenderer>,
    #[prost(message, optional, tag = "84")]
    pub srvr_ctrl_update_renderer: ::core::option::Option<SrvrCtrlUpdateRenderer>,
    #[prost(message, optional, tag = "85")]
    pub srvr_ctrl_remove_renderer: ::core::option::Option<SrvrCtrlRemoveRenderer>,
    #[prost(message, optional, tag = "86")]
    pub srvr_ctrl_active_renderer_changed: ::core::option::Option<
        SrvrCtrlActiveRendererChanged,
    >,
    #[prost(message, optional, tag = "87")]
    pub srvr_ctrl_volume_changed: ::core::option::Option<SrvrCtrlVolumeChanged>,
    #[prost(message, optional, tag = "88")]
    pub srvr_ctrl_queue_error_message: ::core::option::Option<SrvrCtrlQueueErrorMessage>,
    #[prost(message, optional, tag = "89")]
    pub srvr_ctrl_queue_cleared: ::core::option::Option<SrvrCtrlQueueCleared>,
    #[prost(message, optional, tag = "90")]
    pub srvr_ctrl_queue_state: ::core::option::Option<SrvrCtrlQueueState>,
    #[prost(message, optional, tag = "91")]
    pub srvr_ctrl_queue_tracks_loaded: ::core::option::Option<SrvrCtrlQueueLoadTracks>,
    #[prost(message, optional, tag = "92")]
    pub srvr_ctrl_queue_tracks_inserted: ::core::option::Option<
        SrvrCtrlQueueTracksInserted,
    >,
    #[prost(message, optional, tag = "93")]
    pub srvr_ctrl_queue_tracks_added: ::core::option::Option<SrvrCtrlQueueTracksAdded>,
    #[prost(message, optional, tag = "94")]
    pub srvr_ctrl_queue_tracks_removed: ::core::option::Option<
        SrvrCtrlQueueTracksRemoved,
    >,
    #[prost(message, optional, tag = "95")]
    pub srvr_ctrl_queue_tracks_reordered: ::core::option::Option<
        SrvrCtrlQueueTracksReordered,
    >,
    #[prost(message, optional, tag = "96")]
    pub srvr_ctrl_shuffle_mode_set: ::core::option::Option<SrvrCtrlShuffleModeSet>,
    #[prost(message, optional, tag = "97")]
    pub srvr_ctrl_loop_mode_set: ::core::option::Option<SrvrCtrlLoopModeSet>,
    #[prost(message, optional, tag = "98")]
    pub srvr_ctrl_volume_muted: ::core::option::Option<SrvrCtrlVolumeMuted>,
    #[prost(message, optional, tag = "99")]
    pub srvr_ctrl_max_audio_quality_changed: ::core::option::Option<
        SrvrCtrlMaxAudioQualityChanged,
    >,
    #[prost(message, optional, tag = "100")]
    pub srvr_ctrl_file_audio_quality_changed: ::core::option::Option<
        SrvrCtrlFileAudioQualityChanged,
    >,
    #[prost(message, optional, tag = "101")]
    pub srvr_ctrl_device_audio_quality_changed: ::core::option::Option<
        SrvrCtrlDeviceAudioQualityChanged,
    >,
    #[prost(message, optional, tag = "102")]
    pub srvr_ctrl_autoplay_mode_set: ::core::option::Option<SrvrCtrlAutoplayModeSet>,
    #[prost(message, optional, tag = "103")]
    pub srvr_ctrl_autoplay_tracks_loaded: ::core::option::Option<
        SrvrCtrlAutoplayTracksLoaded,
    >,
    #[prost(message, optional, tag = "104")]
    pub srvr_ctrl_autoplay_tracks_removed: ::core::option::Option<
        SrvrCtrlQueueTracksRemoved,
    >,
    #[prost(message, optional, tag = "105")]
    pub srvr_ctrl_queue_version_changed: ::core::option::Option<
        SrvrCtrlQueueVersionChanged,
    >,
}
/// Renderer <-> Server messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RndrSrvrJoinSession {
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub session_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "2")]
    pub device_info: ::core::option::Option<DeviceInfo>,
    #[prost(int32, optional, tag = "3")]
    pub reason: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub initial_state: ::core::option::Option<RendererState>,
    #[prost(bool, optional, tag = "5")]
    pub is_active: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RndrSrvrDeviceInfoUpdated {
    #[prost(message, optional, tag = "1")]
    pub device_info: ::core::option::Option<DeviceInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RndrSrvrStateUpdated {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<QueueRendererState>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RndrSrvrRendererAction {
    #[prost(int32, optional, tag = "1")]
    pub action: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RndrSrvrVolumeChanged {
    #[prost(uint32, optional, tag = "1")]
    pub volume: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RndrSrvrVolumeMuted {
    #[prost(bool, optional, tag = "1")]
    pub value: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RndrSrvrFileAudioQualityChanged {
    #[prost(int32, optional, tag = "1")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RndrSrvrDeviceAudioQualityChanged {
    #[prost(int32, optional, tag = "1")]
    pub value: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RndrSrvrMaxAudioQualityChanged {
    #[prost(int32, optional, tag = "1")]
    pub value: ::core::option::Option<i32>,
}
/// Server -> Renderer commands
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrRndrSetState {
    #[prost(enumeration = "PlayingState", optional, tag = "1")]
    pub playing_state: ::core::option::Option<i32>,
    /// ms
    #[prost(uint32, optional, tag = "2")]
    pub current_position: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(message, optional, tag = "4")]
    pub current_queue_item: ::core::option::Option<QueueTrackRef>,
    #[prost(message, optional, tag = "5")]
    pub next_queue_item: ::core::option::Option<QueueTrackRef>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrRndrSetVolume {
    /// absolute
    #[prost(uint32, optional, tag = "1")]
    pub volume: ::core::option::Option<u32>,
    /// relative
    #[prost(int32, optional, tag = "2")]
    pub volume_delta: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrRndrSetActive {
    #[prost(bool, optional, tag = "1")]
    pub active: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrRndrSetMaxAudioQuality {
    #[prost(int32, optional, tag = "1")]
    pub max_audio_quality: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrRndrSetLoopMode {
    #[prost(enumeration = "LoopMode", optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrRndrSetShuffleMode {
    #[prost(bool, optional, tag = "1")]
    pub shuffle_on: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrRndrSetAutoplayMode {
    #[prost(bool, optional, tag = "1")]
    pub autoplay_on: ::core::option::Option<bool>,
}
/// Controller -> Server (non-queue)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrJoinSession {
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub session_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "2")]
    pub device_info: ::core::option::Option<DeviceInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetPlayerState {
    #[prost(enumeration = "PlayingState", optional, tag = "1")]
    pub playing_state: ::core::option::Option<i32>,
    /// ms
    #[prost(uint32, optional, tag = "2")]
    pub current_position: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub current_queue_item: ::core::option::Option<QueueItemRef>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetActiveRenderer {
    #[prost(int32, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetVolume {
    #[prost(int32, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<i32>,
    /// absolute
    #[prost(uint32, optional, tag = "2")]
    pub volume: ::core::option::Option<u32>,
    /// relative
    #[prost(int32, optional, tag = "3")]
    pub volume_delta: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrMuteVolume {
    #[prost(int32, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub value: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetShuffleMode {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub shuffle_on: ::core::option::Option<bool>,
    #[prost(fixed32, optional, tag = "4")]
    pub current_queue_item_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub shuffle_pivot: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_mode: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetLoopMode {
    #[prost(enumeration = "LoopMode", optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetMaxAudioQuality {
    #[prost(int32, optional, tag = "1")]
    pub max_audio_quality: ::core::option::Option<i32>,
}
/// Controller-originated snapshot; rarely used
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetQueueState {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CtrlSrvrAskForQueueState {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub queue_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrAskForRendererState {
    #[prost(uint64, optional, tag = "1")]
    pub session_id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrSetAutoplayMode {
    #[prost(bool, optional, tag = "1")]
    pub autoplay_on: ::core::option::Option<bool>,
}
/// Mirror of remove
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CtrlSrvrAutoplayRemoveTracks {}
/// Server -> Controllers (non-queue)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlSessionState {
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub session_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag = "2")]
    pub session_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(uint32, optional, tag = "4")]
    pub track_index: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "5")]
    pub unknown: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlRendererStateUpdated {
    #[prost(uint64, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub message_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub state: ::core::option::Option<RendererState>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlAddRenderer {
    #[prost(uint64, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub renderer: ::core::option::Option<DeviceInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlUpdateRenderer {
    #[prost(message, optional, tag = "1")]
    pub renderer: ::core::option::Option<DeviceInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlRemoveRenderer {
    #[prost(uint64, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlActiveRendererChanged {
    #[prost(uint64, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlVolumeChanged {
    #[prost(uint64, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub volume: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlVolumeMuted {
    #[prost(uint64, optional, tag = "1")]
    pub renderer_id: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "2")]
    pub value: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueErrorMessage {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlShuffleModeSet {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub shuffle_on: ::core::option::Option<bool>,
    #[prost(fixed32, optional, tag = "4")]
    pub current_queue_item_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub shuffle_pivot: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "6")]
    pub autoplay_mode: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub autoplay_loading: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "100")]
    pub queue_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlLoopModeSet {
    #[prost(enumeration = "LoopMode", optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlMaxAudioQualityChanged {
    #[prost(int32, optional, tag = "1")]
    pub max_audio_quality: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlFileAudioQualityChanged {
    #[prost(int32, optional, tag = "1")]
    pub file_audio_quality: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlDeviceAudioQualityChanged {
    #[prost(int32, optional, tag = "1")]
    pub device_audio_quality: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlAutoplayModeSet {
    #[prost(bool, optional, tag = "1")]
    pub autoplay_on: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SrvrCtrlAutoplayTracksLoaded {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub action_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub tracks: ::prost::alloc::vec::Vec<QueueTrackRef>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub context_uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SrvrCtrlQueueVersionChanged {
    #[prost(message, optional, tag = "1")]
    pub queue_version: ::core::option::Option<QueueVersion>,
}
/// Message type markers
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QConnectMessageType {
    MessageTypeUnknown = 0,
    MessageTypeError = 1,
    /// Renderer <-> Server
    MessageTypeRndrSrvrJoinSession = 21,
    MessageTypeRndrSrvrDeviceInfoUpdated = 22,
    MessageTypeRndrSrvrStateUpdated = 23,
    MessageTypeRndrSrvrRendererAction = 24,
    MessageTypeRndrSrvrVolumeChanged = 25,
    MessageTypeRndrSrvrFileAudioQualityChanged = 26,
    MessageTypeRndrSrvrDeviceAudioQualityChanged = 27,
    MessageTypeRndrSrvrMaxAudioQualityChanged = 28,
    MessageTypeRndrSrvrVolumeMuted = 29,
    MessageTypeSrvrRndrSetState = 41,
    MessageTypeSrvrRndrSetVolume = 42,
    MessageTypeSrvrRndrSetActive = 43,
    MessageTypeSrvrRndrSetMaxAudioQuality = 44,
    MessageTypeSrvrRndrSetLoopMode = 45,
    MessageTypeSrvrRndrSetShuffleMode = 46,
    MessageTypeSrvrRndrSetAutoplayMode = 47,
    /// Controller -> Server
    MessageTypeCtrlSrvrJoinSession = 61,
    MessageTypeCtrlSrvrSetPlayerState = 62,
    MessageTypeCtrlSrvrSetActiveRenderer = 63,
    MessageTypeCtrlSrvrSetVolume = 64,
    MessageTypeCtrlSrvrClearQueue = 65,
    MessageTypeCtrlSrvrQueueLoadTracks = 66,
    MessageTypeCtrlSrvrQueueInsertTracks = 67,
    MessageTypeCtrlSrvrQueueAddTracks = 68,
    MessageTypeCtrlSrvrQueueRemoveTracks = 69,
    MessageTypeCtrlSrvrQueueReorderTracks = 70,
    MessageTypeCtrlSrvrSetShuffleMode = 71,
    MessageTypeCtrlSrvrSetLoopMode = 72,
    MessageTypeCtrlSrvrMuteVolume = 73,
    MessageTypeCtrlSrvrSetMaxAudioQuality = 74,
    MessageTypeCtrlSrvrSetQueueState = 75,
    MessageTypeCtrlSrvrAskForQueueState = 76,
    MessageTypeCtrlSrvrAskForRendererState = 77,
    MessageTypeCtrlSrvrSetAutoplayMode = 78,
    MessageTypeCtrlSrvrAutoplayAddTracks = 79,
    MessageTypeCtrlSrvrAutoplayRemoveTracks = 80,
    /// Server -> Controllers
    MessageTypeSrvrCtrlSessionState = 81,
    MessageTypeSrvrCtrlRendererStateUpdated = 82,
    MessageTypeSrvrCtrlAddRenderer = 83,
    MessageTypeSrvrCtrlUpdateRenderer = 84,
    MessageTypeSrvrCtrlRemoveRenderer = 85,
    MessageTypeSrvrCtrlActiveRendererChanged = 86,
    MessageTypeSrvrCtrlVolumeChanged = 87,
    MessageTypeSrvrCtrlQueueErrorMessage = 88,
    MessageTypeSrvrCtrlQueueCleared = 89,
    MessageTypeSrvrCtrlQueueState = 90,
    MessageTypeSrvrCtrlQueueTracksLoaded = 91,
    MessageTypeSrvrCtrlQueueTracksInserted = 92,
    MessageTypeSrvrCtrlQueueTracksAdded = 93,
    MessageTypeSrvrCtrlQueueTracksRemoved = 94,
    MessageTypeSrvrCtrlQueueTracksReordered = 95,
    MessageTypeSrvrCtrlShuffleModeSet = 96,
    MessageTypeSrvrCtrlLoopModeSet = 97,
    MessageTypeSrvrCtrlVolumeMuted = 98,
    MessageTypeSrvrCtrlMaxAudioQualityChanged = 99,
    MessageTypeSrvrCtrlFileAudioQualityChanged = 100,
    MessageTypeSrvrCtrlDeviceAudioQualityChanged = 101,
    MessageTypeSrvrCtrlAutoplayModeSet = 102,
    MessageTypeSrvrCtrlAutoplayTracksLoaded = 103,
    MessageTypeSrvrCtrlAutoplayTracksRemoved = 104,
    MessageTypeSrvrCtrlQueueVersionChanged = 105,
}
impl QConnectMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MessageTypeUnknown => "MESSAGE_TYPE_UNKNOWN",
            Self::MessageTypeError => "MESSAGE_TYPE_ERROR",
            Self::MessageTypeRndrSrvrJoinSession => "MESSAGE_TYPE_RNDR_SRVR_JOIN_SESSION",
            Self::MessageTypeRndrSrvrDeviceInfoUpdated => {
                "MESSAGE_TYPE_RNDR_SRVR_DEVICE_INFO_UPDATED"
            }
            Self::MessageTypeRndrSrvrStateUpdated => {
                "MESSAGE_TYPE_RNDR_SRVR_STATE_UPDATED"
            }
            Self::MessageTypeRndrSrvrRendererAction => {
                "MESSAGE_TYPE_RNDR_SRVR_RENDERER_ACTION"
            }
            Self::MessageTypeRndrSrvrVolumeChanged => {
                "MESSAGE_TYPE_RNDR_SRVR_VOLUME_CHANGED"
            }
            Self::MessageTypeRndrSrvrFileAudioQualityChanged => {
                "MESSAGE_TYPE_RNDR_SRVR_FILE_AUDIO_QUALITY_CHANGED"
            }
            Self::MessageTypeRndrSrvrDeviceAudioQualityChanged => {
                "MESSAGE_TYPE_RNDR_SRVR_DEVICE_AUDIO_QUALITY_CHANGED"
            }
            Self::MessageTypeRndrSrvrMaxAudioQualityChanged => {
                "MESSAGE_TYPE_RNDR_SRVR_MAX_AUDIO_QUALITY_CHANGED"
            }
            Self::MessageTypeRndrSrvrVolumeMuted => "MESSAGE_TYPE_RNDR_SRVR_VOLUME_MUTED",
            Self::MessageTypeSrvrRndrSetState => "MESSAGE_TYPE_SRVR_RNDR_SET_STATE",
            Self::MessageTypeSrvrRndrSetVolume => "MESSAGE_TYPE_SRVR_RNDR_SET_VOLUME",
            Self::MessageTypeSrvrRndrSetActive => "MESSAGE_TYPE_SRVR_RNDR_SET_ACTIVE",
            Self::MessageTypeSrvrRndrSetMaxAudioQuality => {
                "MESSAGE_TYPE_SRVR_RNDR_SET_MAX_AUDIO_QUALITY"
            }
            Self::MessageTypeSrvrRndrSetLoopMode => {
                "MESSAGE_TYPE_SRVR_RNDR_SET_LOOP_MODE"
            }
            Self::MessageTypeSrvrRndrSetShuffleMode => {
                "MESSAGE_TYPE_SRVR_RNDR_SET_SHUFFLE_MODE"
            }
            Self::MessageTypeSrvrRndrSetAutoplayMode => {
                "MESSAGE_TYPE_SRVR_RNDR_SET_AUTOPLAY_MODE"
            }
            Self::MessageTypeCtrlSrvrJoinSession => "MESSAGE_TYPE_CTRL_SRVR_JOIN_SESSION",
            Self::MessageTypeCtrlSrvrSetPlayerState => {
                "MESSAGE_TYPE_CTRL_SRVR_SET_PLAYER_STATE"
            }
            Self::MessageTypeCtrlSrvrSetActiveRenderer => {
                "MESSAGE_TYPE_CTRL_SRVR_SET_ACTIVE_RENDERER"
            }
            Self::MessageTypeCtrlSrvrSetVolume => "MESSAGE_TYPE_CTRL_SRVR_SET_VOLUME",
            Self::MessageTypeCtrlSrvrClearQueue => "MESSAGE_TYPE_CTRL_SRVR_CLEAR_QUEUE",
            Self::MessageTypeCtrlSrvrQueueLoadTracks => {
                "MESSAGE_TYPE_CTRL_SRVR_QUEUE_LOAD_TRACKS"
            }
            Self::MessageTypeCtrlSrvrQueueInsertTracks => {
                "MESSAGE_TYPE_CTRL_SRVR_QUEUE_INSERT_TRACKS"
            }
            Self::MessageTypeCtrlSrvrQueueAddTracks => {
                "MESSAGE_TYPE_CTRL_SRVR_QUEUE_ADD_TRACKS"
            }
            Self::MessageTypeCtrlSrvrQueueRemoveTracks => {
                "MESSAGE_TYPE_CTRL_SRVR_QUEUE_REMOVE_TRACKS"
            }
            Self::MessageTypeCtrlSrvrQueueReorderTracks => {
                "MESSAGE_TYPE_CTRL_SRVR_QUEUE_REORDER_TRACKS"
            }
            Self::MessageTypeCtrlSrvrSetShuffleMode => {
                "MESSAGE_TYPE_CTRL_SRVR_SET_SHUFFLE_MODE"
            }
            Self::MessageTypeCtrlSrvrSetLoopMode => {
                "MESSAGE_TYPE_CTRL_SRVR_SET_LOOP_MODE"
            }
            Self::MessageTypeCtrlSrvrMuteVolume => "MESSAGE_TYPE_CTRL_SRVR_MUTE_VOLUME",
            Self::MessageTypeCtrlSrvrSetMaxAudioQuality => {
                "MESSAGE_TYPE_CTRL_SRVR_SET_MAX_AUDIO_QUALITY"
            }
            Self::MessageTypeCtrlSrvrSetQueueState => {
                "MESSAGE_TYPE_CTRL_SRVR_SET_QUEUE_STATE"
            }
            Self::MessageTypeCtrlSrvrAskForQueueState => {
                "MESSAGE_TYPE_CTRL_SRVR_ASK_FOR_QUEUE_STATE"
            }
            Self::MessageTypeCtrlSrvrAskForRendererState => {
                "MESSAGE_TYPE_CTRL_SRVR_ASK_FOR_RENDERER_STATE"
            }
            Self::MessageTypeCtrlSrvrSetAutoplayMode => {
                "MESSAGE_TYPE_CTRL_SRVR_SET_AUTOPLAY_MODE"
            }
            Self::MessageTypeCtrlSrvrAutoplayAddTracks => {
                "MESSAGE_TYPE_CTRL_SRVR_AUTOPLAY_ADD_TRACKS"
            }
            Self::MessageTypeCtrlSrvrAutoplayRemoveTracks => {
                "MESSAGE_TYPE_CTRL_SRVR_AUTOPLAY_REMOVE_TRACKS"
            }
            Self::MessageTypeSrvrCtrlSessionState => {
                "MESSAGE_TYPE_SRVR_CTRL_SESSION_STATE"
            }
            Self::MessageTypeSrvrCtrlRendererStateUpdated => {
                "MESSAGE_TYPE_SRVR_CTRL_RENDERER_STATE_UPDATED"
            }
            Self::MessageTypeSrvrCtrlAddRenderer => "MESSAGE_TYPE_SRVR_CTRL_ADD_RENDERER",
            Self::MessageTypeSrvrCtrlUpdateRenderer => {
                "MESSAGE_TYPE_SRVR_CTRL_UPDATE_RENDERER"
            }
            Self::MessageTypeSrvrCtrlRemoveRenderer => {
                "MESSAGE_TYPE_SRVR_CTRL_REMOVE_RENDERER"
            }
            Self::MessageTypeSrvrCtrlActiveRendererChanged => {
                "MESSAGE_TYPE_SRVR_CTRL_ACTIVE_RENDERER_CHANGED"
            }
            Self::MessageTypeSrvrCtrlVolumeChanged => {
                "MESSAGE_TYPE_SRVR_CTRL_VOLUME_CHANGED"
            }
            Self::MessageTypeSrvrCtrlQueueErrorMessage => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_ERROR_MESSAGE"
            }
            Self::MessageTypeSrvrCtrlQueueCleared => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_CLEARED"
            }
            Self::MessageTypeSrvrCtrlQueueState => "MESSAGE_TYPE_SRVR_CTRL_QUEUE_STATE",
            Self::MessageTypeSrvrCtrlQueueTracksLoaded => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_LOADED"
            }
            Self::MessageTypeSrvrCtrlQueueTracksInserted => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_INSERTED"
            }
            Self::MessageTypeSrvrCtrlQueueTracksAdded => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_ADDED"
            }
            Self::MessageTypeSrvrCtrlQueueTracksRemoved => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_REMOVED"
            }
            Self::MessageTypeSrvrCtrlQueueTracksReordered => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_REORDERED"
            }
            Self::MessageTypeSrvrCtrlShuffleModeSet => {
                "MESSAGE_TYPE_SRVR_CTRL_SHUFFLE_MODE_SET"
            }
            Self::MessageTypeSrvrCtrlLoopModeSet => {
                "MESSAGE_TYPE_SRVR_CTRL_LOOP_MODE_SET"
            }
            Self::MessageTypeSrvrCtrlVolumeMuted => "MESSAGE_TYPE_SRVR_CTRL_VOLUME_MUTED",
            Self::MessageTypeSrvrCtrlMaxAudioQualityChanged => {
                "MESSAGE_TYPE_SRVR_CTRL_MAX_AUDIO_QUALITY_CHANGED"
            }
            Self::MessageTypeSrvrCtrlFileAudioQualityChanged => {
                "MESSAGE_TYPE_SRVR_CTRL_FILE_AUDIO_QUALITY_CHANGED"
            }
            Self::MessageTypeSrvrCtrlDeviceAudioQualityChanged => {
                "MESSAGE_TYPE_SRVR_CTRL_DEVICE_AUDIO_QUALITY_CHANGED"
            }
            Self::MessageTypeSrvrCtrlAutoplayModeSet => {
                "MESSAGE_TYPE_SRVR_CTRL_AUTOPLAY_MODE_SET"
            }
            Self::MessageTypeSrvrCtrlAutoplayTracksLoaded => {
                "MESSAGE_TYPE_SRVR_CTRL_AUTOPLAY_TRACKS_LOADED"
            }
            Self::MessageTypeSrvrCtrlAutoplayTracksRemoved => {
                "MESSAGE_TYPE_SRVR_CTRL_AUTOPLAY_TRACKS_REMOVED"
            }
            Self::MessageTypeSrvrCtrlQueueVersionChanged => {
                "MESSAGE_TYPE_SRVR_CTRL_QUEUE_VERSION_CHANGED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_TYPE_UNKNOWN" => Some(Self::MessageTypeUnknown),
            "MESSAGE_TYPE_ERROR" => Some(Self::MessageTypeError),
            "MESSAGE_TYPE_RNDR_SRVR_JOIN_SESSION" => {
                Some(Self::MessageTypeRndrSrvrJoinSession)
            }
            "MESSAGE_TYPE_RNDR_SRVR_DEVICE_INFO_UPDATED" => {
                Some(Self::MessageTypeRndrSrvrDeviceInfoUpdated)
            }
            "MESSAGE_TYPE_RNDR_SRVR_STATE_UPDATED" => {
                Some(Self::MessageTypeRndrSrvrStateUpdated)
            }
            "MESSAGE_TYPE_RNDR_SRVR_RENDERER_ACTION" => {
                Some(Self::MessageTypeRndrSrvrRendererAction)
            }
            "MESSAGE_TYPE_RNDR_SRVR_VOLUME_CHANGED" => {
                Some(Self::MessageTypeRndrSrvrVolumeChanged)
            }
            "MESSAGE_TYPE_RNDR_SRVR_FILE_AUDIO_QUALITY_CHANGED" => {
                Some(Self::MessageTypeRndrSrvrFileAudioQualityChanged)
            }
            "MESSAGE_TYPE_RNDR_SRVR_DEVICE_AUDIO_QUALITY_CHANGED" => {
                Some(Self::MessageTypeRndrSrvrDeviceAudioQualityChanged)
            }
            "MESSAGE_TYPE_RNDR_SRVR_MAX_AUDIO_QUALITY_CHANGED" => {
                Some(Self::MessageTypeRndrSrvrMaxAudioQualityChanged)
            }
            "MESSAGE_TYPE_RNDR_SRVR_VOLUME_MUTED" => {
                Some(Self::MessageTypeRndrSrvrVolumeMuted)
            }
            "MESSAGE_TYPE_SRVR_RNDR_SET_STATE" => Some(Self::MessageTypeSrvrRndrSetState),
            "MESSAGE_TYPE_SRVR_RNDR_SET_VOLUME" => {
                Some(Self::MessageTypeSrvrRndrSetVolume)
            }
            "MESSAGE_TYPE_SRVR_RNDR_SET_ACTIVE" => {
                Some(Self::MessageTypeSrvrRndrSetActive)
            }
            "MESSAGE_TYPE_SRVR_RNDR_SET_MAX_AUDIO_QUALITY" => {
                Some(Self::MessageTypeSrvrRndrSetMaxAudioQuality)
            }
            "MESSAGE_TYPE_SRVR_RNDR_SET_LOOP_MODE" => {
                Some(Self::MessageTypeSrvrRndrSetLoopMode)
            }
            "MESSAGE_TYPE_SRVR_RNDR_SET_SHUFFLE_MODE" => {
                Some(Self::MessageTypeSrvrRndrSetShuffleMode)
            }
            "MESSAGE_TYPE_SRVR_RNDR_SET_AUTOPLAY_MODE" => {
                Some(Self::MessageTypeSrvrRndrSetAutoplayMode)
            }
            "MESSAGE_TYPE_CTRL_SRVR_JOIN_SESSION" => {
                Some(Self::MessageTypeCtrlSrvrJoinSession)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_PLAYER_STATE" => {
                Some(Self::MessageTypeCtrlSrvrSetPlayerState)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_ACTIVE_RENDERER" => {
                Some(Self::MessageTypeCtrlSrvrSetActiveRenderer)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_VOLUME" => {
                Some(Self::MessageTypeCtrlSrvrSetVolume)
            }
            "MESSAGE_TYPE_CTRL_SRVR_CLEAR_QUEUE" => {
                Some(Self::MessageTypeCtrlSrvrClearQueue)
            }
            "MESSAGE_TYPE_CTRL_SRVR_QUEUE_LOAD_TRACKS" => {
                Some(Self::MessageTypeCtrlSrvrQueueLoadTracks)
            }
            "MESSAGE_TYPE_CTRL_SRVR_QUEUE_INSERT_TRACKS" => {
                Some(Self::MessageTypeCtrlSrvrQueueInsertTracks)
            }
            "MESSAGE_TYPE_CTRL_SRVR_QUEUE_ADD_TRACKS" => {
                Some(Self::MessageTypeCtrlSrvrQueueAddTracks)
            }
            "MESSAGE_TYPE_CTRL_SRVR_QUEUE_REMOVE_TRACKS" => {
                Some(Self::MessageTypeCtrlSrvrQueueRemoveTracks)
            }
            "MESSAGE_TYPE_CTRL_SRVR_QUEUE_REORDER_TRACKS" => {
                Some(Self::MessageTypeCtrlSrvrQueueReorderTracks)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_SHUFFLE_MODE" => {
                Some(Self::MessageTypeCtrlSrvrSetShuffleMode)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_LOOP_MODE" => {
                Some(Self::MessageTypeCtrlSrvrSetLoopMode)
            }
            "MESSAGE_TYPE_CTRL_SRVR_MUTE_VOLUME" => {
                Some(Self::MessageTypeCtrlSrvrMuteVolume)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_MAX_AUDIO_QUALITY" => {
                Some(Self::MessageTypeCtrlSrvrSetMaxAudioQuality)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_QUEUE_STATE" => {
                Some(Self::MessageTypeCtrlSrvrSetQueueState)
            }
            "MESSAGE_TYPE_CTRL_SRVR_ASK_FOR_QUEUE_STATE" => {
                Some(Self::MessageTypeCtrlSrvrAskForQueueState)
            }
            "MESSAGE_TYPE_CTRL_SRVR_ASK_FOR_RENDERER_STATE" => {
                Some(Self::MessageTypeCtrlSrvrAskForRendererState)
            }
            "MESSAGE_TYPE_CTRL_SRVR_SET_AUTOPLAY_MODE" => {
                Some(Self::MessageTypeCtrlSrvrSetAutoplayMode)
            }
            "MESSAGE_TYPE_CTRL_SRVR_AUTOPLAY_ADD_TRACKS" => {
                Some(Self::MessageTypeCtrlSrvrAutoplayAddTracks)
            }
            "MESSAGE_TYPE_CTRL_SRVR_AUTOPLAY_REMOVE_TRACKS" => {
                Some(Self::MessageTypeCtrlSrvrAutoplayRemoveTracks)
            }
            "MESSAGE_TYPE_SRVR_CTRL_SESSION_STATE" => {
                Some(Self::MessageTypeSrvrCtrlSessionState)
            }
            "MESSAGE_TYPE_SRVR_CTRL_RENDERER_STATE_UPDATED" => {
                Some(Self::MessageTypeSrvrCtrlRendererStateUpdated)
            }
            "MESSAGE_TYPE_SRVR_CTRL_ADD_RENDERER" => {
                Some(Self::MessageTypeSrvrCtrlAddRenderer)
            }
            "MESSAGE_TYPE_SRVR_CTRL_UPDATE_RENDERER" => {
                Some(Self::MessageTypeSrvrCtrlUpdateRenderer)
            }
            "MESSAGE_TYPE_SRVR_CTRL_REMOVE_RENDERER" => {
                Some(Self::MessageTypeSrvrCtrlRemoveRenderer)
            }
            "MESSAGE_TYPE_SRVR_CTRL_ACTIVE_RENDERER_CHANGED" => {
                Some(Self::MessageTypeSrvrCtrlActiveRendererChanged)
            }
            "MESSAGE_TYPE_SRVR_CTRL_VOLUME_CHANGED" => {
                Some(Self::MessageTypeSrvrCtrlVolumeChanged)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_ERROR_MESSAGE" => {
                Some(Self::MessageTypeSrvrCtrlQueueErrorMessage)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_CLEARED" => {
                Some(Self::MessageTypeSrvrCtrlQueueCleared)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_STATE" => {
                Some(Self::MessageTypeSrvrCtrlQueueState)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_LOADED" => {
                Some(Self::MessageTypeSrvrCtrlQueueTracksLoaded)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_INSERTED" => {
                Some(Self::MessageTypeSrvrCtrlQueueTracksInserted)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_ADDED" => {
                Some(Self::MessageTypeSrvrCtrlQueueTracksAdded)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_REMOVED" => {
                Some(Self::MessageTypeSrvrCtrlQueueTracksRemoved)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_TRACKS_REORDERED" => {
                Some(Self::MessageTypeSrvrCtrlQueueTracksReordered)
            }
            "MESSAGE_TYPE_SRVR_CTRL_SHUFFLE_MODE_SET" => {
                Some(Self::MessageTypeSrvrCtrlShuffleModeSet)
            }
            "MESSAGE_TYPE_SRVR_CTRL_LOOP_MODE_SET" => {
                Some(Self::MessageTypeSrvrCtrlLoopModeSet)
            }
            "MESSAGE_TYPE_SRVR_CTRL_VOLUME_MUTED" => {
                Some(Self::MessageTypeSrvrCtrlVolumeMuted)
            }
            "MESSAGE_TYPE_SRVR_CTRL_MAX_AUDIO_QUALITY_CHANGED" => {
                Some(Self::MessageTypeSrvrCtrlMaxAudioQualityChanged)
            }
            "MESSAGE_TYPE_SRVR_CTRL_FILE_AUDIO_QUALITY_CHANGED" => {
                Some(Self::MessageTypeSrvrCtrlFileAudioQualityChanged)
            }
            "MESSAGE_TYPE_SRVR_CTRL_DEVICE_AUDIO_QUALITY_CHANGED" => {
                Some(Self::MessageTypeSrvrCtrlDeviceAudioQualityChanged)
            }
            "MESSAGE_TYPE_SRVR_CTRL_AUTOPLAY_MODE_SET" => {
                Some(Self::MessageTypeSrvrCtrlAutoplayModeSet)
            }
            "MESSAGE_TYPE_SRVR_CTRL_AUTOPLAY_TRACKS_LOADED" => {
                Some(Self::MessageTypeSrvrCtrlAutoplayTracksLoaded)
            }
            "MESSAGE_TYPE_SRVR_CTRL_AUTOPLAY_TRACKS_REMOVED" => {
                Some(Self::MessageTypeSrvrCtrlAutoplayTracksRemoved)
            }
            "MESSAGE_TYPE_SRVR_CTRL_QUEUE_VERSION_CHANGED" => {
                Some(Self::MessageTypeSrvrCtrlQueueVersionChanged)
            }
            _ => None,
        }
    }
}
